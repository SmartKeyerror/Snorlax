

#include <string>

using namespace std;


/*
 * 使用 0 和 1 这两个数字组成 string of n 表示的数字，并返回所需的最小数字个数。例如 "32" = "11" + "11" + "10"，答案为 3。
 * 
 * 比较 tricky 的一道题目，一开始准备用 DP 来做，但是看到 1 <= n.length <= 10^5 这个条件后放弃，必须在 O(n) 的时间内完成。
 * 
 * 以 "85172" 为例，我们将其进行 "分解":
 * 
 *   8 5 1 7 2
 * 
 *   1 1 1 1 1
 *   1 1 0 1 1
 *   1 1 0 1 0
 *   1 1 0 1 0
 *   1 1 0 1 0
 *   1 0 0 1 0
 *   1 0 0 1 0
 *   1 0 0 0 0
 * 
 * 简单的来说，就是如果 n 的某一个不为 '0' 的话，那么我们就用 '1' 去填充，或者说，“贪婪” 地填充。
 * 
 * 如此一来，最终的答案就是 n 中最大的那一位，对于 "85172" 而言，最大的位为 "8"，所以最终的答案为 8。
 */
class Solution {
public:
    int minPartitions(string n) {
        return *max_element(n.begin(), n.end()) - '0';
    }
};