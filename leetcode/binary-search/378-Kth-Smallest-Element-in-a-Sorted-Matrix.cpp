
#include <vector>

using namespace std;

/*
 * 在一个 n x n 的数组中，每一行和每一列都按照升序进行排序，求该二维数组中第 k 小的元素。
 *
 * 这道题可以用堆来做，但是这样的话就浪费掉了数组本身有序这个特点了。
 * 
 * - 如果用堆来做的话，很简单，构建一个大小为 k 的最大堆（堆顶元素最大），将二维数组所有的元素丢到堆中，然后返回堆顶元素即可。时间复杂度为 O(n^2logn)。
 * 
 * - 再来看二分搜索的方式。用二分搜索求第 k 小的元素和普通的二分搜索存在一些差别。普通的二分搜索是对索引进行二分，而这里，需要对值进行二分。
 * 
 *  1  5  9
 *  10 11 13
 *  12 13 15
 * 
 * 以该二维矩阵，且 k = 3 为例。显而易见的，二维数组中的最小值为 matrix[0][0]，也就是 1 ，最大值为 matrix[n-1][n-1]，也就是 15。
 * 
 * 我们需要在 [1, 15] 这个值域中寻找第 3 小的元素。首先对值域进行二分，得到中间值: (1 + 15) / 2 = 8。来看看比 8 小的元素有多少个（含等于）: 1, 5 比 8 小，其它的都比 8 要大。
 * 
 * 也就是说，当前数组中比 8 小的元素一共只有 2 个，但是我们要求第 3 小元素，3 > 2，所以我们需要到 [8 + 1, 15] 这个值域进行查找。(9 + 15) / 2 = 12。比 12 小（含等于）的元素一共有  6 个。
 * 
 * 6 > 3，所以我们调整上界，也就是在 [9, 12] 中进行搜索。(9 + 12) / 2 = 10，比 10 小（含等于）的元素个数为 4，4 > 3，所以我们调整上届，也就是在 [9, 10] 中进行搜索。
 * 
 * (9 + 10) / 2 = 9，比 9 小的元素个数为 3，3 == 3，所以我们需要调整上届。当 count == k 时，并不代表我们找到了解，因为此时 mid 在数组中可能并不存在。
 * 
 * 所以，此时我们需要在 [9, 9] 中进行查找。left 和 right 相等，退出查找过程，返回 left 即可。最终答案也就是 9。
 * 
 */
class Solution {
public:
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        int n = matrix.size();
        int left = matrix[0][0], right = matrix[n-1][n-1];

        while (left < right) {
            int mid = left + (right - left) / 2, count = 0;
            for (int i = 0; i < n; i++)
                count += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();
            if (count < k)
                left = mid + 1;
            else
                right = mid;
        }
        return left;
    }
};