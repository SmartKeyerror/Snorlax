

#include <vector>
#include <algorithm>

using namespace std;


/*
 * 一道找规律的问题
 * 
 * [1,4,3,2,6,5] 的下一个排列是 [1,4,3,5,2,6]
 * [1,6,2,3,5,4] 的下一个排列是 [1,6,2,4,3,5]
 * [6,5,4,3,2,1] 的下一个排列是 [1,2,3,4,5,6]
 * 
 * 对于 1, 4, 3, 2, 6, 5 而言，从后向前看，数字逐渐增大，直到 2 停止，然后再从后往前找比 2 大的第一个数字，结果为 5, 交换 2 和 5 的位置，变成 [1,4,3,5,6,2]
 * 然后 reverse 5 以后的元素，也就是 [1,4,3,5,2,6]
 * 
 * 
 * 现在来分析以下为什么这样做就可以得到下一个排列， 以 [1, 2, 6, 5, 4] 为例
 * 
 * 因为我们的排序是需要 nums 数组所组成的 int 逐渐增大的，也就是从 12456 到 12465，既然如此，[6, 5, 4] 已经是这 3 个数所能组成的最大值了，我们无法重新对这 3 个数进行排列，然后得到更大的数。
 * 
 * 因此，我们首先需要从 nums 的末尾开始，找到那个“下降点”，或者说 “拐点”，在上例中为 2，也就是说，我们需要对 [2, 6, 5, 4] 这四个数字进行重新排列，使其得到下一个更大的数字。
 * 
 * 又因为排列具有连续性，我们不能够随意的进行排列，例如变成 [6, 2, 5, 4]，得找到 Next Greater Number。所以，我们再次从 nums 的末尾开始搜索，寻找第一个大于 2 的元素，这个元素将作为新的排列的首个元素，我们找到了 4。
 * 
 * 不管剩下的 3 个数字，下一个排列一定是 [4, x, x, x]，此时如果我们将这两个元素的位置进行互换，互换元素之后的 3 个元素依然可以保持连续增大的特性，因为我们一开始就是在找拐点，找完拐点之后还和第一个比拐点大的元素交换了位置，
 * 
 * 连续增大的特性不会被破坏，此时就变成了 [1, 4, 6, 5, 2]。那么剩下的只需要将连续增大的这一部分数字 reverse 一下，使其代表的数字变得更小即可，也就是 [1, 4, 2, 5, 6]。
 * 
 * 这就好像天平一样，一部分权重增大，另一部分权重得减小，才能维持天平的平衡。
 * 
 * 明白了这一点以后，Previous Permutation 问题我们也能够求解了。
 */
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        for (int i = nums.size() - 2; i >= 0; i--) {
            if (nums[i+1] > nums[i]) {
                for (int j = nums.size() - 1; j > i; j--) {
                    if (nums[j] > nums[i]){
                        swap(nums[i], nums[j]);
                        break;
                    }
                }
                reverse(nums.begin() + i + 1, nums.end());
                return;
            }
        }
        reverse(nums.begin(), nums.end());
    }
};
